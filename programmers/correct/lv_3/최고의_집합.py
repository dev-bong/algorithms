def solution(n, s):
    if n > s: # 가장 작은 자연수인 1로만 n개를 골라도 합이 s를 넘기때문에 안됨
        return [-1]

    d = s // n
    answer = [d] * n # s를 n으로 나눈 몫들이 n개가 있는 리스트
    
    if (n * d) == s: #* 1번 경우
        return answer
    elif (n * d) < s: #* 2번 경우
        remain = s - (n * d) # 남은 수
        
        idx = 0
        while remain: # 남은 수를 answer 배열에다가 돌아가면서 1씩 넘겨줌 (카드패 돌리듯이 하나씩). 각 자연수 사이의 차이를 줄이기 위함
            answer[idx] += 1
            idx = (idx + 1) % s
            remain -= 1
        
        answer.sort()
        return answer

"""
"집합"이란 말에 낚시 X. 중복을 허용하는 중복 집합임

#* 풀이 방법
    1. n개 자연수의 합이 s이면서, 자연수간의 곱이 최대인 경우는..?
        >> 자연수들의 합이 같다면, 각 자연수들간의 차이가 작을수록 곱은 커진다!!
        ex>
            n = 2, s = 9 >> [4, 5]
            n = 3, s = 9 >> [3, 3, 3]
            n = 3, s = 10 >> [3, 3, 4]

    #* 1번 경우
        n = 4, s = 8 >> [2, 2, 2, 2]
        n = 3, s = 9 >> [3, 3, 3]

        위 경우처럼 딱 나누어 떨어지는 경우
    #* 2번 경우
        n = 2, s = 9 >> [4, 5]
        n = 3, s = 10 >> [3, 3, 4]
"""